/* USB Audio Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/

#include <stdint.h>
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "sdkconfig.h"
#include "tinyusb.h"
#include "tusb_audio.h"
#include "driver/i2s_std.h"
#include "sig_gen.h"
#include "driver/gpio.h"

#define SAMPLES_BYTES_NUM CFG_TUD_AUDIO_EP_SZ_IN
#define SAMPLES_NUM CFG_TUD_AUDIO_EP_SZ_IN / 2

static const char *TAG = "USB audio example";

uint16_t audio_buffer[SAMPLES_BYTES_NUM];

//! Add more channels if needed. Needs to be initialized and packed correctly
sig_gen_t sine_ch1;
sig_gen_t sine_ch2;


#define EXAMPLE_STD_BCLK_IO1 GPIO_NUM_7  // I2S bit clock io number
#define EXAMPLE_STD_WS_IO1 GPIO_NUM_46   // I2S word select io number
#define EXAMPLE_STD_DOUT_IO1 GPIO_NUM_10 // I2S data out io number
#define EXAMPLE_STD_DIN_IO1 GPIO_NUM_5   // I2S data in io number


#define EXAMPLE_BUFF_SIZE (48*8)

static i2s_chan_handle_t tx_chan; // I2S tx channel handler
static i2s_chan_handle_t rx_chan; // I2S rx channel handler



typedef struct sample_buffers
{
    uint8_t  *buffer0;
    uint8_t  *buffer1;
    uint8_t  *buffer2;
    
    uint8_t next_write_index;
    uint8_t next_read_index;
    uint8_t buffer_count;

}sample_buffers;

sample_buffers sam_bufs; 

void init_buffers(sample_buffers *sb){
    sb->buffer_count = 3;
    sb->buffer0 = (uint8_t *)calloc(1, EXAMPLE_BUFF_SIZE);
    sb->buffer1 = (uint8_t *)calloc(1, EXAMPLE_BUFF_SIZE);
    sb->buffer2 = (uint8_t *)calloc(1, EXAMPLE_BUFF_SIZE);
    assert(sb->buffer0);

    sb->next_write_index = 1;
    sb->next_read_index = 0; 

}

uint8_t * get_next_read_buffer(sample_buffers *sb){


    // if(sb->next_write_index == 0){
    //     gpio_set_level(GPIO_NUM_17, 0);
      
    //     //gpio_set_level(GPIO_NUM_14, 0);
    //     return sb->buffer2;
    // }
    // if(sb->next_write_index == 1){
    //     gpio_set_level(GPIO_NUM_17, 1);

    //     return sb->buffer0;
    // }
    // if(sb->next_write_index == 2){
    //     gpio_set_level(GPIO_NUM_17, 0);
        
    //     return sb->buffer1;
    
    // }
    return sb->buffer2;
    
}


    // if(sb->next_read_index == 0){
    //     sb->next_read_index++;
    //     return sb->buffer0;
    // }
    // if(sb->next_read_index == 1){
    //     sb->next_read_index++;
    //     return sb->buffer1;
    // }
    // if(sb->next_read_index == 2){
    //     sb->next_read_index = 0;
    //     return sb->buffer2;
    // }
    // return 0;
    



uint8_t * get_next_write_buffer(sample_buffers *sb,bool increment){

    // if(sb->next_write_index == 0){
    //     gpio_set_level(GPIO_NUM_18, 0);
    //     sb->next_write_index+=increment;
    //     //gpio_set_level(GPIO_NUM_14, 0);
    //     return sb->buffer0;

    // }
    // if(sb->next_write_index == 1){
    //     gpio_set_level(GPIO_NUM_18, 1);
    //     sb->next_write_index+=incremenreturn sb->buffer2;

    //     //gpio_set_level(GPIO_NUM_14, 1);

    //     return sb->buffer1;
    // }
    // if(sb->next_write_index == 2){
    //     gpio_set_level(GPIO_NUM_18, 0);
    //     if(increment){
    //     sb->next_write_index = 0;
    //     }
    //     return sb->buffer2;
    // }
    return sb->buffer2;
    

}



static void i2s_example_read_task(void *args)
{

    uint8_t * r_buf;
    //assert(r_buf); // Check if r_buf allocation success
    size_t r_bytes = 0;
    //int16_t *r_buf_16 = (int16_t *)r_buf;



    /* ATTENTION: The print and delay in the read task only for monitoring the data by human,
     * Normally there shouldn't be any delays to ensure a short polling time,
     * Otherwise the dma buffer will overflow and lead to the data lost */
    while (1)
    {
        r_buf = get_next_write_buffer(&sam_bufs,1);
        //printf("%p",r_buf);
        gpio_set_level(GPIO_NUM_12, 1);
        /* Read i2s data */
        if (i2s_channel_read(rx_chan, r_buf, EXAMPLE_BUFF_SIZE, &r_bytes, 1000) == ESP_OK)
        {
            gpio_set_level(GPIO_NUM_12, 0);
            //gpio_set_level(GPIO_NUM_14, 1);
            //for(int i=0;i<48;i+=4){
            //    printf("%i",*(r_buf_16 + (i+1)));
            //}
            //printf("%i%i  %i%i\n\n", *r_buf_16, *(r_buf_16 + 1), *(r_buf_16 + 2), *(r_buf_16 + 3));
            //gpio_set_level(GPIO_NUM_14, 0);
        }
        else
        {
            printf("Read Task: i2s read failed\n");
        }
        
    }
    free(r_buf);
    vTaskDelete(NULL);
}







static void i2s_example_init_std_duplex(void)
{
    /* Setp 1: Determine the I2S channel configuration and allocate both channels
     * The default configuration can be generated by the helper macro,
     * it only requires the I2S controller id and I2S role */
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_SLAVE);
    chan_cfg.dma_frame_num = EXAMPLE_BUFF_SIZE/8;
    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_chan, &rx_chan));

    /* Step 2: Setting the configurations of standard mode, and initialize rx & tx channels
     * The slot configuration and clock configuration can be generated by the macros
     * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
     * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(48000),
        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED, // some codecs may require mclk signal, this example doesn't need it
            .bclk = EXAMPLE_STD_BCLK_IO1,
            .ws = EXAMPLE_STD_WS_IO1,
            .dout = EXAMPLE_STD_DOUT_IO1,
            .din = EXAMPLE_STD_DIN_IO1, // In duplex mode, bind output and input to a same gpio can loopback internally
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };
    /* Initialize the channels */
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));
}




void tinyusb_audio_tx_callback(uint8_t *buffer, uint16_t *bytes)

{   
    gpio_set_level(GPIO_NUM_14, 1);
    uint8_t* pointer8 = get_next_read_buffer(&sam_bufs);
    //uint16_t ch1_samples[48];
    //uint16_t ch2_samples[48];
    // Get samples from signal generator
    //sig_gen_output(&sine_ch1, (uint8_t *)ch1_samples, 48);
    //sig_gen_output(&sine_ch2, (uint8_t *)ch2_samples, 48);
    
    gpio_set_level(GPIO_NUM_14, 0);

    // Arrange samples in buffer
    uint16_t *p_buff = audio_buffer;
    uint16_t *pointer16 = (uint16_t *)pointer8;
    for (int samples_num = 0; samples_num < 48; samples_num+=1)
    {
        //gpio_set_level(GPIO_NUM_17, 1);
        *p_buff++ = *(pointer16+((samples_num*4)+1));
        *p_buff++ = *(pointer16+((samples_num*4)+3));//ch2_samples[samples_num];
        //gpio_set_level(GPIO_NUM_17, 0);
    }
    gpio_set_level(GPIO_NUM_14, 1);
    memcpy(buffer, audio_buffer, SAMPLES_BYTES_NUM);
    *bytes = SAMPLES_BYTES_NUM;
    gpio_set_level(GPIO_NUM_14, 0);
}




void app_main(void)
{
    ESP_LOGI(TAG, "USB initialization");

    init_buffers(&sam_bufs);
    
    gpio_set_direction(GPIO_NUM_12, GPIO_MODE_OUTPUT);
    gpio_set_direction(GPIO_NUM_14, GPIO_MODE_OUTPUT);
    gpio_set_direction(GPIO_NUM_17, GPIO_MODE_OUTPUT);
    gpio_set_direction(GPIO_NUM_18, GPIO_MODE_OUTPUT);
    gpio_set_level(GPIO_NUM_12, 1);

    i2s_example_init_std_duplex();

    ESP_ERROR_CHECK(i2s_channel_enable(rx_chan));

    



    // Configure signal generator
    sig_gen_config_t sig_gen_cfg = {
        .gen_source = SINE_LUT,
        .lut_freq = LUT_FREQ_440,
        .bytes_per_sample = CFG_TUD_AUDIO_FUNC_1_N_BYTES_PER_SAMPLE_TX,
        .sample_rate = 48000,
        .endianess = SIG_GEN_LE,
        .enable_cb = SIG_GEN_NO_CB};
    sig_gen_init(&sine_ch1, &sig_gen_cfg);
    sig_gen_cfg.lut_freq = LUT_FREQ_552;
    sig_gen_init(&sine_ch2, &sig_gen_cfg);

    // Configure tinyusb audio
    tinyusb_config_audio_t audio_cfg = {
        .audio_tx_callback = &tinyusb_audio_tx_callback};
    tusb_audio_init(&audio_cfg);

    // Install TINYUSB driver
    tinyusb_config_t tusb_cfg = {
        .external_phy = false,
    };
    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));
    xTaskCreate(i2s_example_read_task, "i2s_example_read_task", 4096, NULL, 5, NULL);
}
